/**
 * Core Philosophy: This ruleset enforces a hybrid security model that supports both
 * private, user-owned data and collaborative, team-based data. The primary goal is
 * strict authorization while maintaining flexibility for rapid application development.
 *
 * Data Structure: The data is organized into four top-level collections: 'users',
 * 'teams', 'tasks', and 'notes'. This flat structure is designed for efficient querying.
 *
 * Key Security Decisions:
 * - Denormalization for Authorization: To ensure fast and simple authorization checks,
 *   critical auth data is denormalized. 'tasks' and 'notes' documents contain an
 *   'ownerId', and 'teams' documents contain a 'members' array of user IDs. This
 *   avoids costly and complex cross-document lookups in rules.
 * - Hybrid Access Model: 'tasks' and 'notes' can either be private to an owner or
 *   shared within a team. Access is granted if the requesting user is the owner OR a
 *   member of the associated team.
 * - Team Membership: Access to team documents and their associated tasks/notes is
 *   controlled by the 'members' array within each '/teams/{teamId}' document.
 * - No User Listing: The '/users' collection cannot be listed to protect user privacy.
 * - Client-Side Query Reliance: For collections like 'tasks' and 'notes' with
 *   document-level permissions, list operations are permitted for any signed-in user.
 *   This is a deliberate prototyping decision that enables flexible client-side
 *   queries (e.g., fetching tasks by owner or team). It relies on the client
 *   application to construct secure queries that only request data the user is
 *   authorized to see.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    
    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update/delete.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * Checks if the authenticated user is a member of a given team.
     * This requires reading the team document.
     */
    function isTeamMember(teamId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/teams/$(teamId)).data.members;
    }

    /**
     * @description A user can manage their own profile document. No other user can read or write it.
     * @path /users/{userId}
     * @allow A user (uid: 'user123') can create their own profile at /users/user123. (create)
     * @deny A user (uid: 'user456') cannot read the profile of 'user123'. (get)
     * @principle Restricts access to a user's own data tree and enforces path-to-data consistency.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Team documents can be read and updated only by their members.
     * @path /teams/{teamId}
     * @allow A user who is in the 'members' array of team 'abc' can read /teams/abc. (get)
     * @deny A user not in the 'members' array of team 'abc' cannot update it. (update)
     * @principle Enforces shared access based on a denormalized list of collaborators (members).
     */
    match /teams/{teamId} {
      allow get: if isTeamMember(teamId);
      allow list: if false; // Disallow listing all teams for security.
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.members;
      allow update: if resource != null && isTeamMember(teamId);
      allow delete: if false; // Deleting teams is a destructive action, disabled for clients.
    }

    /**
     * @description Tasks can be accessed by their owner or members of the team they belong to.
     * @path /tasks/{taskId}
     * @allow A user (uid: 'user123') can create a task with 'ownerId' set to 'user123'. (create)
     * @deny A user cannot update a task where they are not the 'ownerId' or a team member. (update)
     * @principle Implements a hybrid ownership and shared-access model. It relies on denormalized
     * 'ownerId' and 'teamId' fields on the task document itself.
     */
    match /tasks/{taskId} {
      allow get: if resource.data.ownerId == request.auth.uid || (resource.data.teamId != null && isTeamMember(resource.data.teamId));
      allow list: if isSignedIn(); // Allows client to perform queries like .where('ownerId', '==', uid)
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid && (request.resource.data.teamId == null || isTeamMember(request.resource.data.teamId));
      allow update: if resource != null && (resource.data.ownerId == request.auth.uid || (resource.data.teamId != null && isTeamMember(resource.data.teamId))) && request.resource.data.ownerId == resource.data.ownerId;
      allow delete: if resource != null && (resource.data.ownerId == request.auth.uid || (resource.data.teamId != null && isTeamMember(resource.data.teamId)));
    }
    
    /**
     * @description Notes can be accessed by their owner or members of the project (team) they belong to.
     * @path /notes/{noteId}
     * @allow A user can read a note if their UID is the 'ownerId'. (get)
     * @deny A user cannot delete a note that belongs to a project they are not a member of. (delete)
     * @principle Implements a hybrid ownership and shared-access model, similar to tasks. It uses
     * the 'projectId' field to link to a team for collaborative access.
     */
    match /notes/{noteId} {
      allow get: if resource.data.ownerId == request.auth.uid || (resource.data.projectId != null && isTeamMember(resource.data.projectId));
      allow list: if isSignedIn(); // Allows client to perform queries like .where('ownerId', '==', uid)
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid && (request.resource.data.projectId == null || isTeamMember(request.resource.data.projectId));
      allow update: if resource != null && (resource.data.ownerId == request.auth.uid || (resource.data.projectId != null && isTeamMember(resource.data.projectId))) && request.resource.data.ownerId == resource.data.ownerId;
      allow delete: if resource != null && (resource.data.ownerId == request.auth.uid || (resource.data.projectId != null && isTeamMember(resource.data.projectId)));
    }
  }
}